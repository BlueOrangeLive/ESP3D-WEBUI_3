<script type="text/javascript">
    let min_x_machine = 0.0000;
    let min_y_machine = 0.0000;
    let max_x_machine = 100.0000;
    let max_y_machine = 100.0000;
    let precision = 2; 
    let steps_X = 5;
    let steps_Y = 10;
    let margin = 40; // Définir la taille de la marge
    let xPos = 0;
    let yPos = 0;
    let lastXValid = margin;
    let lastYValid = margin;
    let inZone = false;
    let lastClickPosition = null;
    const margin_pad_left= 10;
    const margin_pad_top = 20;

    const iconsToLoad = ["Crosshair", "Settings"];
    const loadedIcons = {};
    let iconsLoaded = false;

    const buttons = [
    {
        icon: "Crosshair",
        text: "Go",
        onClick: "fn1"
    },
    {
        icon: "Settings",
        text: "Settings",
        onClick: "fn2"
    }
];

function fn1() {
    console.log("Fonction 1 appelée");
}

function fn2() {
    console.log("Fonction 2 appelée");
}

   
    function sendMessage(msg) {
        window.parent.postMessage(msg, '*');
    }

    function processMessage(eventMsg) {
    console.log("Message reçu:", eventMsg.data); // Ajout d'un console.log
    if (!iconsLoaded) {
        if (eventMsg.data.type && eventMsg.data.id && iconsToLoad.includes(eventMsg.data.id)) {
            if (eventMsg.data.type === "icon") {
                const iconName = eventMsg.data.id;
                const iconSvg = eventMsg.data.content.response;
                loadedIcons[iconName] = iconSvg;
                console.log(`Icône ${iconName} chargée:`, iconSvg);

                console.log("Nombre d'icônes chargées:", Object.keys(loadedIcons).length); // Ajout d'un console.log
                console.log("Nombre d'icônes à charger:", iconsToLoad.length); // Ajout d'un console.log
                if (Object.keys(loadedIcons).length === iconsToLoad.length) {
                    console.log("Toutes les icônes sont chargées !");
                    useLoadedIcons();
                    iconsLoaded = true;
                }
            }
        }
    }
}

function loadIcons() {
    console.log("Chargement des icônes..."); // Ajout d'un console.log
    iconsToLoad.forEach(iconName => {
        sendMessage({ type: 'icon', target: 'webui', id: iconName });
    });
}

function useLoadedIcons() {
    const buttonContainer = document.querySelector(".button-container");

    buttons.forEach(button => {
        const btn = document.createElement("button");
        btn.classList.add("btn", "m-1");
        const span = document.createElement("span");
        span.classList.add("feather-icon-container");
        span.innerHTML = loadedIcons[button.icon];
        btn.appendChild(span);
        const label = document.createElement("label");
        label.innerHTML = `${button.text}`;
        btn.appendChild(label);
        btn.setAttribute("data-icon", button.icon);
        btn.addEventListener("click", () => {
            window[button.onClick]();
        });
        buttonContainer.appendChild(btn);
    });
}

function handleButtonClick(event) {
    const clickedIcon = event.currentTarget.getAttribute("data-icon");
    console.log(`Bouton cliqué avec l'icône : ${clickedIcon}`);
    
    const button = buttons.find(btn => btn.icon === clickedIcon);
    if (button && typeof window[button.onClick] === "function") {
        window[button.onClick]();
    }
}



    function initExtension() {
        updateCanvasSize();
        window.addEventListener('resize', updateCanvasSize);
        const canvas = document.getElementById('machine-canvas');
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('click', handleClick);
        const ctx = canvas.getContext('2d');
        ctx.font = window.getComputedStyle(canvas).getPropertyValue('--axis-label-font-step');
        const textMetrics = ctx.measureText(max_x_machine.toFixed(precision).toString());
        const textWidth = textMetrics.width;
        margin = Math.ceil(textWidth) + margin_pad_left*2;
        lastXValid = margin;
        lastYValid = margin;
    }

    function updateCanvasSize() {
        // Récupérer les dimensions du conteneur du canvas
        const container = document.getElementById('machine-container');
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        let canvasSize;

        if (containerWidth < containerHeight) {
            canvasSize = containerWidth;
        } else {
            canvasSize = containerHeight;
        }

        // Mettre à jour les dimensions du canvas
        const canvas = document.getElementById('machine-canvas');
        canvas.width = canvasSize;
        canvas.height = canvasSize;

        // Redessiner le contenu du canvas
        drawCanvas();
    }

    function drawAxes() {
        const canvas = document.getElementById('machine-canvas');
        const ctx = canvas.getContext('2d');
        const canvasWidth = canvas.width - margin * 2;
        const canvasHeight = canvas.height - margin * 2;

        ctx.font = window.getComputedStyle(canvas).getPropertyValue('--axis-label-font-step');
        ctx.fillStyle = window.getComputedStyle(canvas).getPropertyValue('--axis-label-font-step-color');
        // Dessiner l'axe X
        ctx.beginPath();
        ctx.moveTo(margin, canvas.height - margin);
        ctx.lineTo(canvas.width - margin, canvas.height - margin);
        ctx.strokeStyle = window.getComputedStyle(canvas).getPropertyValue('--axis-color');
        ctx.stroke();

        // Dessiner l'axe Y
        ctx.beginPath();
        ctx.moveTo(margin, margin);
        ctx.lineTo(margin, canvas.height - margin);
        ctx.strokeStyle = window.getComputedStyle(canvas).getPropertyValue('--axis-color');
        ctx.stroke();

        // Dessiner les échelles sur l'axe X
        const numXDivisions = steps_X;
        const xDivisionWidth = canvasWidth / numXDivisions;
        for (let i = 0; i <= numXDivisions; i++) {
            const x = margin + i * xDivisionWidth;
            ctx.beginPath();
            ctx.moveTo(x, canvas.height - margin - 5);
            ctx.lineTo(x, canvas.height - margin + 5);
            ctx.strokeStyle = window.getComputedStyle(canvas).getPropertyValue('--axis-color');
            ctx.stroke();

            const xValue = min_x_machine + (i * (max_x_machine - min_x_machine) / numXDivisions);
            ctx.fillText(xValue.toFixed(precision), x, canvas.height - margin + margin_pad_top);
        }

        // Dessiner les échelles sur l'axe Y
        const numYDivisions = steps_Y;
        const yDivisionHeight = canvasHeight / numYDivisions;
        for (let i = 0; i <= numYDivisions; i++) {
            const y = canvas.height - margin - i * yDivisionHeight;
            ctx.beginPath();
            ctx.moveTo(margin - 5, y);
            ctx.lineTo(margin + 5, y);
            ctx.strokeStyle = window.getComputedStyle(canvas).getPropertyValue('--axis-color');
            ctx.stroke();

            const yValue = min_y_machine + (i * (max_y_machine - min_y_machine) / numYDivisions);
            ctx.fillText(yValue.toFixed(precision), margin_pad_left, y);
        }

        ctx.beginPath();
        ctx.font = window.getComputedStyle(canvas).getPropertyValue('--axis-label-font');
        ctx.fillStyle = window.getComputedStyle(canvas).getPropertyValue('--axis-label-font-color');
        ctx.fillText('X', canvas.width - margin + 10, canvas.height - margin + 5);
        ctx.fillText('Y', margin - 5, margin - 10);
        ctx.stroke();
    }

    function drawCanvas() {
        const canvas = document.getElementById('machine-canvas');
        const ctx = canvas.getContext('2d');

        // Effacer le contenu précédent du canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Remplir la zone en gris clair avec une marge uniforme
        ctx.fillStyle = ctx.strokeStyle = window.getComputedStyle(canvas).getPropertyValue('--background-color');
        ctx.fillRect(margin, margin, canvas.width - margin * 2, canvas.height - margin * 2);
        drawAxes()
        drawPositionInfo(); // Appeler la fonction pour dessiner les informations de position
    }

    function drawCrosshair(xadj, yadj) {
        const canvas = document.getElementById('machine-canvas');
        const ctx = canvas.getContext('2d');
        let x = xadj;
        let y = yadj;

        const isOutsideZone = xadj < margin || xadj > canvas.width - margin || yadj < margin || yadj > canvas.height - margin;

        if (isOutsideZone) {
            canvas.style.cursor = 'default';
            if (inZone) {
                if (xadj < margin) {
                    lastXValid = margin;
                } else if (xadj > canvas.width - margin) {
                    lastXValid = canvas.width - margin;
                }

                if (yadj < margin) {
                    lastYValid = margin;
                } else if (yadj > canvas.height - margin) {
                    lastYValid = canvas.height - margin;
                }

                inZone = false;
            }

            x = lastXValid;
            y = lastYValid;
        } else {
            inZone = true;
            canvas.style.cursor = 'none';
            if (x < margin) {
                x = margin;
            } else if (x > canvas.width - margin) {
                x = canvas.width - margin;
            }

            if (y < margin) {
                y = margin;
            } else if (y > canvas.height - margin) {
                y = canvas.height - margin;
            }

            lastXValid = x;
            lastYValid = y;
        }
        xPos = x;
        yPos = y;

        ctx.beginPath();
        ctx.moveTo(x, margin);
        ctx.lineTo(x, canvas.height - margin);
        ctx.moveTo(margin, y);
        ctx.lineTo(canvas.width - margin, y);
        ctx.strokeStyle = ctx.strokeStyle = window.getComputedStyle(canvas).getPropertyValue('--cursor-color');
        ctx.stroke();
    }

    function convertToVirtualCoordinates(x, y) {
    const canvas = document.getElementById('machine-canvas');
    const canvasWidth = canvas.width - margin * 2;
    const canvasHeight = canvas.height - margin * 2;

    const virtualX = ((x - margin) / canvasWidth) * (max_x_machine - min_x_machine) + min_x_machine;
    const virtualY = ((canvasHeight - (y - margin)) / canvasHeight) * (max_y_machine - min_y_machine) + min_y_machine;

    return { x: virtualX, y: virtualY };
}

function drawPositionInfo() {
    const canvas = document.getElementById('machine-canvas');
    const ctx = canvas.getContext('2d');

    // Dessiner la position actuelle du curseur
    const cursorPosition = convertToVirtualCoordinates(xPos, yPos);
    
    ctx.font = window.getComputedStyle(canvas).getPropertyValue('--positions-font');
    ctx.fillStyle = window.getComputedStyle(canvas).getPropertyValue('--positions-font-color');
    ctx.fillText(`X: ${cursorPosition.x.toFixed(precision)}, Y: ${cursorPosition.y.toFixed(precision)}`, margin*2, 20);

    // Dessiner les coordonnées du dernier clic
    if (lastClickPosition) {
        const ctx2 = canvas.getContext('2d');
        ctx2.font = window.getComputedStyle(canvas).getPropertyValue('--last-click-font');
        ctx2.fillStyle = window.getComputedStyle(canvas).getPropertyValue('--last-click-font-color');
        ctx2.fillText(`Xc: ${lastClickPosition.x.toFixed(precision)}, Yc: ${lastClickPosition.y.toFixed(precision)}`, margin*2, 35);

    }
}
    function handleMouseMove(event) {
        const canvas = document.getElementById('machine-canvas');
        const rect = canvas.getBoundingClientRect();

        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const x = (event.offsetX || event.clientX - rect.left) * scaleX;
        const y = (event.offsetY || event.clientY - rect.top) * scaleY;

        const adjustedX = Math.max(0, Math.min(x, canvas.width));
        const adjustedY = Math.max(0, Math.min(y, canvas.height));

        drawCanvas();
        drawCrosshair(adjustedX, adjustedY);
    }

    function handleClick(event) {

        if (inZone) {
            const virtualCoords = convertToVirtualCoordinates(xPos, yPos);
            lastClickPosition = virtualCoords; // Stocker les coordonnées du dernier clic
            drawCanvas(); // Redessiner le canvas pour effacer le curseur
            drawCrosshair(xPos, yPos);
        }
    }



    // Onload add listener to collect messages from WebUI and init extension
// Onload add listener to collect messages from WebUI and init extension
window.onload = (event) => {
    console.log("Extension chargée"); // Ajout d'un console.log
    window.addEventListener("message", processMessage, false);
    initExtension();
    loadIcons();
};
</script>
<style>
    body,
    html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    #machine-container {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
        padding: 20px;
        box-sizing: border-box;
    }

    #machine-canvas {
        max-width: 100%;
        max-height: calc(100% - 50px);
        border: 1px solid black;
        margin-bottom: 20px;
        --axis-label-font-step: 9px Arial, sans-serif;
        --axis-label-font-step-color: black;
        --axis-label-font: 16px Arial, sans-serif;
        --axis-label-font-color: black;
        --axis-color: blue;
        --background-color: lightgray;
        --cursor-color: red;
        --positions-font: 12px Arial;
        --positions-font-color: red;
        --last-click-font: 12px Arial;
        --last-click-font-color: blue;
    }

    .button-container {
        display: flex;
        justify-content: space-between;
        width: 100%;
        max-width: 400px;
        margin-top: 10px;
    }

</style>

<div id="machine-container">
    <canvas id="machine-canvas"></canvas>
    <div class="button-container"></div>
</div>